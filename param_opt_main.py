import sys
import argparse
from logging import getLogger, StreamHandler, FileHandler, Formatter, INFO, DEBUG
import numpy as np
import random
import shutil
import os
import time
import yaml
import pickle
import subprocess
from QCforever.qcforever.gaussian_run import GaussianRunPack
from bayes_opt import BayesianOptimization, UtilityFunction
from rdkit import Chem
from rdkit.Chem import AllChem

def get_parser():
    parser = argparse.ArgumentParser(
        description="Optimize parameter",
        usage=f"python {os.path.basename(__file__)} -c CONFIG_FILE"
    )
    parser.add_argument(
        "-c", "--config", type=str, required=True,
        help="path to a config file"
    )
    parser.add_argument(
        "-d", "--debug", action='store_true',
        help="debug mode"
    )
    return parser.parse_args()

def get_logger(level, save_dir):
    logger = getLogger(__name__)
    logger.setLevel(level)
    logger.propagate = False
    formatter = Formatter("%(asctime)s : %(levelname)s : %(message)s ")
    fh = FileHandler(filename=os.path.join(save_dir, "run.log"), mode='w')
    fh.setLevel(level)
    fh.setFormatter(formatter)
    sh = StreamHandler()
    sh.setLevel(level)
    sh.setFormatter(formatter)
    logger.addHandler(fh)
    logger.addHandler(sh)
    return logger

def set_default_config(conf):
    conf.setdefault('index', 0)
    conf.setdefault('smiles', 'C=O')
    conf.setdefault('result_prefix', '')

    conf.setdefault('init_Gau_option', 'opt freq')
    conf.setdefault('init_functional', 'lc-blyp')
    conf.setdefault('init_basis', 'STO-3G')
    conf.setdefault('init_solvent', '0')
    
    conf.setdefault('opt_Gau_option', 'satkoopmans')
    conf.setdefault('opt_functional', 'lc-blyp')
    conf.setdefault('opt_mu', 0.33)
    conf.setdefault('opt_basis', 'STO-3G')
    conf.setdefault('opt_solvent', '0')
    conf.setdefault('koopmans_cond', 'VIP')

    conf.setdefault('calc_best_parameter', False)
    conf.setdefault('best_Gau_option', 'satkoopmans deen vip vea homolumo dipole uv fluor tadf')

    conf.setdefault('gau_core', 1)
    conf.setdefault('gau_mem', '4GB')
    conf.setdefault('gau_time', 60*60)
    
    conf.setdefault('calc_set_parameter', False)

    conf.setdefault('bo_strategy', 'EI')
    conf.setdefault('bo_init_num', 2)
    conf.setdefault('bo_search_num', 10)
    conf.setdefault('bo_cam_search_num', 10)
    conf.setdefault('bo_stop_threshold', 0.01)

    conf.setdefault('debug', False)
    
class Simulator:
    
    def __init__(self, conf, logger):
        self.conf = conf
        self.logger = logger
        self.init_result_dict = None
        self.bo_result_dict = []
        self.best_result_dict = None
        
    def init_struct_opt(self):
        index = self.conf['index']
        smi = self.conf['smiles']
        gau_time = int(self.conf['gau_time'])
        core = self.conf['gau_core']
        mem = self.conf['gau_mem']
        option = self.conf['init_Gau_option']
        basis = self.conf['init_basis']
        functional = self.conf['init_functional']
        max_atomic_num = np.max([atom.GetAtomicNum() for atom in Chem.MolFromSmiles(smi).GetAtoms()])
        solvent = self.conf['init_solvent'] #If set solvent, then freq fails.
        self.SDFinput = f'InitMol{index}.sdf'
        self.SDFinput_MMopt = f'InitMol_MMopt{index}.sdf'
        self.SDFinput_LAQA = f'InitMol_LAQAopt{index}.sdf'
        self.fchk_DFTopt = f'InitMol_DFTopt{index}.fchk'
        self.search_count = 0

        #Initial optimization of molecular conformation by MMFF
        if os.path.isfile(self.fchk_DFTopt):
            self.logger.info('The initial structure optimized by DFT already exists.')
            return None
        mol_wH = Chem.AddHs(Chem.MolFromSmiles(smi))
        AllChem.EmbedMolecule(mol_wH, AllChem.ETKDG())
        Chem.MolToMolFile(mol_wH, self.SDFinput)
        try:
            opt = AllChem.MMFFOptimizeMolecule(mol_wH, maxIters=200)
            print('3D by ETKDG and MMFFOpt')
        except:
            print('ETKDG failed.')
            opt=None
        
        Chem.MolToMolFile(mol_wH, self.SDFinput_MMopt)
        if opt == None or opt == -1:
            print('MMFF with conf generated by ETKDG')
            subprocess.run(f'echo "{smi}" | obabel -i smi -o sdf -O {self.SDFinput} --gen3D', timeout = 60*30,  shell=True)
            sdfinfo = Chem.SDMolSupplier(self.SDFinput, removeHs=False)
            for mol in sdfinfo:
                mol_wH = mol
            try:
                OB_opt = AllChem.MMFFOptimizeMolecule(mol_wH, maxIters=200)
                print('3D by obabel and MMFFOpt')
            except:
                OB_opt=None
        Chem.MolToMolFile(mol_wH, self.SDFinput_MMopt)
        

        # Conformational optimization by ChemLAQA
        param_file = 'laqa_confopt_uff_gfn2-xtb.inp'
        laqa_dir = f'LAQAopt{index}'

        if os.path.isdir(laqa_dir):
            shutil.rmtree(laqa_dir)
        os.mkdir(laqa_dir)

        shutil.copy(param_file, laqa_dir)
        os.chdir(laqa_dir)

        with open(param_file) as f:
            laqa_inp = f.readlines()
        self.logger.debug(f'laqa_inp: {laqa_inp}')
        laqa_inp[1] = 'smiles = "'+Chem.MolToSmiles(mol_wH, isomericSmiles=True)+'"\n'
        
        with open(param_file, 'w') as f:
            f.writelines(laqa_inp)
        
        try:
            my_env = os.environ.copy()
            my_env["OMP_NUM_THREADS"] = "16"
            my_env["OMP_STACKSIZE"] = "4G"

            start_time = time.time()
            p = subprocess.run(['python', '../chem_laqa/laqa_confopt.py', param_file], timeout = 60*30,  shell=False, env=my_env)
            
            print(f'LAQA returncode: {p.returncode},stdout: {p.stdout},stderr: {p.stderr}')
            calc_time = time.time() - start_time
            
            if os.path.exists('optimized_structures.sdf'):
                laqa_flag = 1
                sup_list = Chem.SDMolSupplier('optimized_structures.sdf', removeHs=False)
                writer=Chem.SDWriter(f'../{self.SDFinput_LAQA}')
                writer.write(sup_list[0])
                writer.close()
            else:
                laqa_flag = 0
        except Exception as e:
            laqa_flag = 0
            print('LAQA failed:', e)

        os.chdir('..')
        shutil.move(laqa_dir, self.conf['output_dir'])

        # Optimize conformation by DFT (Gaussian) and calculate property
        SDFinput_forDFT = f'InitMol_DFT{index}.sdf'
        if laqa_flag == 1:
            shutil.copy(self.SDFinput_LAQA, SDFinput_forDFT)
        else:
            shutil.copy(self.SDFinput_MMopt, SDFinput_forDFT)
        GRP = GaussianRunPack.GaussianDFTRun(functional, basis, core, option, SDFinput_forDFT, solvent=solvent, restart=True)

        
        GRP.mem = mem
        GRP.timexe = gau_time
        
        self.init_result_dict = GRP.run_gaussian()
        self.logger.debug(f'init_result_dict: {self.init_result_dict}')
        with open(f'{self.conf["output_dir"]}/init_calc_result_dict.pkl', 'wb') as f:
            pickle.dump(self.init_result_dict, f)

        
        calc_dir = SDFinput_forDFT.split('.')[0]
        shutil.copy(f'{calc_dir}/{calc_dir}.fchk', self.fchk_DFTopt)
        shutil.move(self.SDFinput, calc_dir)
        shutil.move(self.SDFinput_MMopt, calc_dir)
        if os.path.exists(self.SDFinput_LAQA):
            shutil.move(self.SDFinput_LAQA, calc_dir)
        shutil.move(SDFinput_forDFT, calc_dir)
        shutil.move(calc_dir, self.conf['output_dir'])

    def get_diff(self, mu, a = 0, b = 0):
        
        if a + b > 1.0:
            return - 10
        
        tmp_input_file = f'{self.fchk_DFTopt.split(".")[0]}_{self.search_count}.fchk'
        self.search_count += 1

        shutil.copy(self.fchk_DFTopt, tmp_input_file)

        self.logger.debug(f'Input file: {tmp_input_file}')
        GRP = GaussianRunPack.GaussianDFTRun(self.conf['opt_functional'], 
            self.conf['opt_basis'],
            self.conf['gau_core'],
            self.conf['opt_Gau_option'],
            tmp_input_file,
            solvent=self.conf['opt_solvent'],
            restart=False
        )


        #parameter setting of functional
        if self.conf['opt_functional'] == 'lc-blyp':
            GRP.para_functional = [mu] #range=[0,1]
        elif self.conf['opt_functional'] == 'cam-b3lyp':
            GRP.para_functional = [mu, a, b] #Let [a,b,c], a is the same as LC ([0,1]). b+c<=1. 
        self.logger.debug(f'functional: {self.conf["opt_functional"]}, functional parameter: {GRP.para_functional}')
         
        GRP.mem = self.conf['gau_mem']
        GRP.timexe = self.conf['gau_time']
        
        outdic = GRP.run_gaussian()
        outdic['lc_param'] = GRP.para_functional
        self.bo_result_dict.append(outdic)
        self.logger.debug(f'Properties: {outdic}')
        if self.conf['koopmans_cond'] == 'VIP':
            difference = outdic['satkoopmans'][0]
        elif self.conf['koopmans_cond'] == 'VEA':
            difference = outdic['satkoopmans'][0]
        elif self.conf['koopmans_cond'] == 'both':
            difference = np.abs(outdic['satkoopmans'][0]) + np.abs(outdic['satkoopmans'][1])
        
        self.logger.debug(f'satkoopmans: {outdic["satkoopmans"]}')
        
        os.remove(tmp_input_file)
        calc_dir = tmp_input_file.split('.')[0]
        shutil.move(calc_dir, self.conf['output_dir'])

        return - difference**2

    def best_para_run(self, best_params):
        tmp_input_file = f'{self.fchk_DFTopt.split(".")[0]}_best.fchk'
        shutil.copyfile(self.fchk_DFTopt, tmp_input_file)

        self.logger.debug(f'Input file: {tmp_input_file}')
        GRP = GaussianRunPack.GaussianDFTRun(self.conf['opt_functional'], 
            self.conf['opt_basis'],
            self.conf['gau_core'],
            self.conf['best_Gau_option'],
            tmp_input_file,
            solvent=self.conf['opt_solvent'],
            restart=False
        )

        #parameter setting of functional
        if self.conf['opt_functional'] == 'lc-blyp':
            GRP.para_functional = [best_params['params']['mu']] #range=[0,1]
        elif self.conf['opt_functional'] == 'cam-b3lyp':
            GRP.para_functional = [best_params['params']['mu'],
                best_params['params']['a'],
                best_params['params']['b']
            ] #Let [a,b,c], a is the same as LC ([0,1]). b+c<=1. 
        self.logger.debug(f'functional: {self.conf["opt_functional"]}, functional parameter: {GRP.para_functional}')
        
        GRP.mem = self.conf['gau_mem']
        GRP.timexe = self.conf['gau_time']
        
        outdic = GRP.run_gaussian()
        outdic['lc_param'] = GRP.para_functional
        self.best_result_dict = outdic
        self.logger.debug(f'Properties: {outdic}')
        
        with open(f'{self.conf["output_dir"]}/best_param_calc_result_dict.pkl', 'wb') as f:
            pickle.dump(self.best_result_dict, f)

        os.remove(tmp_input_file)
        calc_dir = tmp_input_file.split('.')[0]
        shutil.move(calc_dir, self.conf['output_dir'])

    def option_run(self):
        tmp_input_file = f'{self.fchk_DFTopt.split(".")[0]}_set_param.fchk'
        shutil.copyfile(self.fchk_DFTopt, tmp_input_file)

        self.logger.debug(f'Input file: {tmp_input_file}')
        GRP = GaussianRunPack.GaussianDFTRun(self.conf['set_functional'], 
            self.conf['set_basis'],
            self.conf['gau_core'],
            self.conf['set_Gau_option'],
            tmp_input_file,
            solvent=self.conf['set_solvent'],
            restart=False
        )
        
        GRP.mem = self.conf['gau_mem']
        GRP.timexe = self.conf['gau_time']
        
        outdic = GRP.run_gaussian()
        self.best_result_dict = outdic
        self.logger.debug(f'Properties: {outdic}')
        
        with open(f'{self.conf["output_dir"]}/set_param_calc_result_dict.pkl', 'wb') as f:
            pickle.dump(self.best_result_dict, f)

        os.remove(tmp_input_file)
        calc_dir = tmp_input_file.split('.')[0]
        shutil.move(calc_dir, self.conf['output_dir'])


def bo_search(conf, gaussian_simulator, logger):
    
    if conf['opt_functional'] == 'lc-blyp':
        pbounds = { 'mu': (0, 1), }
    elif conf['opt_functional'] == 'cam-b3lyp':
        #pbounds = {'mu': (conf['opt_mu'], conf['opt_mu']), 'a': (0, 1), 'b': (0, 1), }
        pbounds = {'mu': (0, 1), 'a': (0, 1), 'b': (0, 1), }

    bo = BayesianOptimization(
        f=gaussian_simulator.get_diff,
        pbounds=pbounds,
        verbose=2,
        random_state = int(conf["index"]),
    )
    
    EI = UtilityFunction(kind="ei", xi=1e-4)
    
    if conf['bo_strategy'] == 'EI':
        if conf['opt_functional'] == 'lc-blyp':
            bo.set_bounds(new_bounds={'mu': (0.47,0.47)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.33,0.33)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.22,0.22)})
            bo.maximize(init_points=1, n_iter=0)
        elif conf['opt_functional'] == 'cam-b3lyp':
            bo.set_bounds(new_bounds={'mu': (0.47, 0.47), 'a': (0,0), 'b': (0,0)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.33, 0.33), 'a': (1,1), 'b': (0,0)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.22, 0.22), 'a': (0,0), 'b': (1,1)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.33, 0.33),'a': (0.19,0.19), 'b': (0.46,0.46)})
            bo.maximize(init_points=1, n_iter=0)


        bo.set_bounds(new_bounds=pbounds)
        if conf['opt_functional'] == 'lc-blyp':
            bo_iteration = conf['bo_search_num']
        elif conf['opt_functional'] == 'cam-b3lyp':
            bo_iteration = conf['bo_cam_search_num']
        
        for i in range(bo_iteration):
            bo.maximize(init_points=0, n_iter=1, acquisition_function=EI)
            logger.debug(f'bo.res: { bo.res}')
            if np.sqrt(np.abs(bo.res[-1]['target'])) < conf['bo_stop_threshold']:
                break
    

    elif conf['bo_strategy'] == 'random':
        if conf['opt_functional'] == 'lc-blyp':
            bo.set_bounds(new_bounds={'mu': (0.47,0.47)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.33,0.33)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.22,0.22)})
            bo.maximize(init_points=1, n_iter=0)

            bo.set_bounds(new_bounds={'mu': (0, 1)})

        elif conf['opt_functional'] == 'cam-b3lyp':
            bo.set_bounds(new_bounds={'mu': (0.47, 0.47), 'a': (0,0), 'b': (0,0)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.33, 0.33), 'a': (1,1), 'b': (0,0)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.22, 0.22), 'a': (0,0), 'b': (1,1)})
            bo.maximize(init_points=1, n_iter=0)
            bo.set_bounds(new_bounds={'mu': (0.33, 0.33),'a': (0.19,0.19), 'b': (0.46,0.46)})
        
        bo.maximize(init_points=conf['bo_search_num'], n_iter=0)
   
    best_parameter = None
    best_dif = -np.inf
    for res in bo.res:
        if res['target'] > best_dif:
            best_parameter = res
            best_dif = res['target']

    logger.info(f'Best parameter: {best_parameter}')
    
    with open(f'{conf["output_dir"]}/bo_calc_result_dict.pkl', 'wb') as f:
        pickle.dump(gaussian_simulator.bo_result_dict, f)
    
    return best_parameter

def main():
    args = get_parser()
    with open(args.config, "r") as f:
        conf = yaml.load(f, Loader=yaml.SafeLoader)
    set_default_config(conf)
    output_dir = f'{conf["result_prefix"]}result{conf["index"]}'
    conf['output_dir'] = output_dir
    if os.path.isdir(conf['output_dir']):
        shutil.rmtree(conf['output_dir'])
    os.makedirs(output_dir)
    subprocess.run(f'rm -rf InitMol{conf["index"]}.sdf', shell=True)
    subprocess.run(f'rm -rf InitMol_MMopt{conf["index"]}.sdf', shell=True)
    subprocess.run(f'rm -rf InitMol_MMopt{conf["index"]}', shell=True)
    subprocess.run(f'rm -rf InitMol_DFTopt{conf["index"]}.fchk', shell=True)
    subprocess.run(f'rm -rf InitMol_DFTopt{conf["index"]}', shell=True)

    # basis
    max_atomic_num = np.max([atom.GetAtomicNum() for atom in Chem.MolFromSmiles(conf['smiles']).GetAtoms()])
    if max_atomic_num >= 37:
        conf['opt_basis'] = 'LANL2DZ'
        conf['init_basis'] = 'LANL2DZ'

    # set log level
    log_level = DEBUG if conf['debug'] else INFO
    logger = get_logger(log_level, f'{conf["output_dir"]}')
    if conf['debug']:
        conf['fix_random_seed'] = True
    
    logger.info(f"========== Configuration ==========")
    for k, v in conf.items():
        logger.info(f"{k}: {v}")
    logger.info(f"===================================")

    logger.info('Initial structure optimization...')
    gaussian_simulator = Simulator(conf, logger)
    gaussian_simulator.init_struct_opt()

    logger.info('Baysian optimization of parameter...')
    if conf['opt_functional'] == 'lc-blyp':
        best_params = bo_search(conf, gaussian_simulator, logger)
    
    elif conf['opt_functional'] == 'cam-b3lyp':
        #Optimization of mu using LC-BLYP
        if conf['opt_mu'] < 0:
            conf['opt_functional'] = 'lc-blyp'
            best_params = bo_search(conf, gaussian_simulator, logger)
            conf['opt_mu'] = best_params['params']['mu']
        
        #Optimization of alpha and beta of CAM with fixed mu
        conf['opt_functional'] = 'cam-b3lyp'
        best_params = bo_search(conf, gaussian_simulator, logger)


    if conf['calc_best_parameter']:
        logger.info('Property calculation with the best parameter...')
        gaussian_simulator.best_para_run(best_params)
        with open(f'{conf["output_dir"]}/best_param_calc_result_dict.pkl', 'wb') as f:
            pickle.dump(gaussian_simulator.best_result_dict, f)

    if conf['calc_set_parameter']:
        logger.info('Property calculation with the option parameter...')
        gaussian_simulator.option_run()


        
    shutil.move(gaussian_simulator.fchk_DFTopt, conf['output_dir'])

if __name__=='__main__':
    main()
